{
  "assignment_info": "SEER
Society for Electronics Engineering and Research
Digital Assignment

There is a system with a master-slave relation between 2 chipsâ€”A and B wherein A acts as the
master, B acts as the slave, and both share the same clock. Your task is to design a pipelined RTL
Model of B.

A sends 2 4-bit-wide signals encoding 2 64-bit numbers from MSB to LSB and a start signal indicating
data is valid or not, i.e., if the control signal is 1, B should start storing the encoded 64 bit numbers.

B employs a 64*64 multiplier to compute the product of the data received.
The 64Ã—64-bit multiplier employed uses the Karatsuba multiplication algorithm to compute the output
The Karatsuba algorithm works by breaking down a large multiplication into smaller
multiplications, which helps in optimizing the hardware area.
In this design, a dual-layer Karatsuba multiplier should be used. This means that the large
multiplication is first divided into smaller multiplications, and then those smaller multiplications are
further divided again using the same Karatsuba approach.
Only one small multiplier is available in the design for area optimization. This multiplier should be
reused to compute all the partial products.
The control logic for sequencing these operations and combining the partial products into the final
64Ã—64 result must be implemented using a finite state machine (FSM).
The clock latency of the multiplier designed must not be greater than the clock latency of the input
cycle for maximised efficiency.
Hint: Read the algorithm carefully and determine the most optimal multiplier that can be used.

A Reads/ B Writes

Note

Sample Module Header For B

Deliverables
A has a single 8-bit-wide signal to read the data. A sends a T_Ready control signal and only
reads when this signal is logic HIGH. The T_Ready signal can be logic LOW for a maximum
of 96 clock cycles, and all the data must be sent to A in order of its execution from LSB to
MSB. Set up a buffer to ensure no data is overwritten.

If B has no data left and the T_Ready signal is HIGH, B shall parse 1111.
The A Writes/B Reads and the Execution stages must be independent and pipelined ie a
new input can be taken during the execution of the previous cycle.
First input data comes with start = 1.
Ensure the Karatsuba 64*64 bit Multiplier can multiply for all possible combinations of the
inputs.

module B(
input clk,
input rst,
input t_ready,
input start,
input [3:0] Data_in1,
input [3:0] Data_in2,
output [7:0] Data_out
);

Verilog Code for the Design.
Testbench and simulation result for the created design.
Synthesis and Implementation Report for the created design. Include LUT, FF, and DSP
count for ZedBoard ZYNQ 7000.
STA Analysisâ€”Give the maximum clock cycle achievable by the design, report the WNS
and WHS at this clock speed
NOTE: Each deliverable carries separate points

",
  "files": [
    {
      "filename": "karatsuba34.sv",
      "content": "module karatsuba34 (\n    input  logic        clk,\n    input  logic        rst,\n    input  logic        start,\n    input  logic [33:0] A,       // 34-bit input\n    input  logic [33:0] B,       // 34-bit input\n    output logic [67:0] P,       // 34x34 -> 68-bit product\n    output logic        valid_out\n);\n\n    // --- Split inputs into 18-bit halves ---\n    logic [17:0] A_hi, A_lo, B_hi, B_lo;\n    logic [35:0] z0, z1, z2;     // \n    logic d0, d1, d2;\n\n    // Small multiplier start signals\n    logic start_m0, start_m1, start_m2;\n\n    // Assign halves\n    assign A_hi = A[33:17];       // upper 18 bits\n    assign A_lo = A[16:0] ;\n    assign B_hi = B[33:17];\n    assign B_lo = B[16:0];\n\n    logic [17:0] sumA;\n    logic [17:0] sumB;\nassign sumA = {1'b0, A_hi} + {1'b0, A_lo};\nassign sumB = {1'b0, B_hi} + {1'b0, B_lo};\n\n    // // Display info\n    // always @(posedge clk) begin\n    //     if (start) begin\n    //         $display(\"----------------------------------------------------------------------------------\");\n    //         $display(\"[%0t]34 Input A=%d (%0d bits), B=%d (%0d bits)\", \n    //                 $time, A, $bits(A), B, $bits(B));\n    //         $display(\"[%0t]34 A_hi=%d (%0d bits), A_lo=%d (%0d bits), B_hi=%d (%0d bits), B_lo=%d (%0d bits)\", \n    //                 $time, A_hi, $bits(A_hi), A_lo, $bits(A_lo), B_hi, $bits(B_hi), B_lo, $bits(B_lo));\n    //         $display(\"[%0t]34 sumA=%d (%0d bits), sumB=%d (%0d bits)\", \n    //                 $time, sumA, $bits(sumA), sumB, $bits(sumB));\n    //         $display(\"----------------------------------------------------------------------------------\");\n    //     end\n    // end\n\n    // Instantiate 18x18 multipliers\n    mult18 m0 (.clk(clk), .rst(rst), .start(start_m0), .A(A_lo), .B(B_lo), .P(z0), .done(d0));\n    mult18 m1 (.clk(clk), .rst(rst), .start(start_m1), .A(A_hi), .B(B_hi), .P(z1), .done(d1));\n    mult18 m2 (.clk(clk), .rst(rst), .start(start_m2), .A(sumA), .B(sumB), .P(z2), .done(d2));\n\n    // FSM states\n    typedef enum logic [2:0] {\n        IDLE,\n        START_P0, WAIT_P0,\n        START_P1, WAIT_P1,\n        START_P2, WAIT_P2,\n        COMBINE\n    } state_t;\n\n    state_t state;\n\n    // Output register\n    logic [71:0] P_reg;\n    assign P = P_reg;\n    logic valid_reg;\n    assign valid_out = valid_reg;\n    logic [100:0] P_full;\n                    logic [71:0] z0_ext, z1_ext, mid_ext;\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            P_reg <= 0;\n            valid_reg <= 0;\n            start_m0 <= 0;\n            start_m1 <= 0;\n            start_m2 <= 0;\n        end else begin\n            // default\n            start_m0 <= 0;\n            start_m1 <= 0;\n            start_m2 <= 0;\n            valid_reg <= 0;\n\n            case(state)\n                IDLE: begin\n                    if (start) state <= START_P0;\n                end\n\n                START_P0: begin\n                    start_m0 <= 1;\n                    state <= WAIT_P0;\n                end\n                WAIT_P0: if (d0) state <= START_P1;\n\n                START_P1: begin\n                    start_m1 <= 1;\n                    state <= WAIT_P1;\n                end\n                WAIT_P1: if (d1) state <= START_P2;\n\n                START_P2: begin\n                    start_m2 <= 1;\n                    state <= WAIT_P2;\n                end\n                WAIT_P2: if (d2) state <= COMBINE;\n\n                COMBINE: begin\n                    \n            z0_ext  = {{36{1'b0}}, z0};          // 36-bit z0 into 72 bits\n        z1_ext  = {{36{1'b0}}, z1} << 34;    // 36-bit z1 shifted into upper half\n        mid_ext = {{36{1'b0}}, (z2 - z1 - z0)} << 17;\n                    \n\n    // $display(\"[%0t] --- COMBINE STAGE ---\", $time);\n    // $display(\"   z0   = %d\", z0);\n    // $display(\"   z1   = %d\", z1);\n    // $display(\"   z2   = %d\", z2);\n    // $display(\"   mid  = %d (before shift)\", (z2 - z1 - z0));\n    // $display(\"   z0_ext  = %d\", z0_ext);\n    // $display(\"   z1_ext  = %d\", z1_ext);\n    // $display(\"   mid_ext = %d\", mid_ext);\n    // P_full = z1_ext + mid_ext + z0_ext;\n\n    // $display(\"   --> Combined P = %h\", P_full);\n                    P_reg <= z1_ext + mid_ext + z0_ext;\n                    valid_reg <= 1;\n                end\n            endcase\n        end\n    end\n\nendmodule\n"
    },
    {
      "filename": "karatsuba64.sv",
      "content": "module karatsuba64 (\n    input  logic        clk,\n    input  logic        rst,\n    input  logic        start,\n    input  logic [63:0] A,\n    input  logic [63:0] B,\n    output logic [127:0] P,\n    output logic        valid_out\n);\n\n    // Split 64-bit inputs\n    logic [33:0] A_hi, A_lo, B_hi, B_lo;\n    assign A_hi = A[63:32];\n    assign A_lo = A[31:0];\n    assign B_hi = B[63:32];\n    assign B_lo = B[31:0];\n\n    // Sum of high and low parts (32+1 bits to avoid overflow)\n    logic [33:0] sumA, sumB;\n    assign sumA = A_hi + A_lo;\n    assign sumB = B_hi + B_lo;\n\n    // Outputs of 32x32 Karatsuba units\n    logic [67:0] z0, z1, z2;\n    logic        v0, v1, v2;\n\n    // Start signals for submodules\n    logic start_z0, start_z1, start_z2;\n\n    // Debug display\n    always @(posedge clk) begin\n        if (start) begin\n            $display(\"----------------------------------------------------------------------------------\");\n            $display(\"[%0t] [Kb_64] Input A=%d (%0d bits), B=%d (%0d bits)\", \n                     $time, A, $bits(A), B, $bits(B));\n            $display(\"[%0t]64 A_hi=%d (%0d bits), A_lo=%d (%0d bits), B_hi=%d (%0d bits), B_lo=%d (%0d bits)\", \n                     $time, A_hi, $bits(A_hi), A_lo, $bits(A_lo), B_hi, $bits(B_hi), B_lo, $bits(B_lo));\n            $display(\"[%0t]64 sumA=%d (%0d bits), sumB=%d (%0d bits)\", \n                     $time, sumA, $bits(sumA), sumB, $bits(sumB));\n            $display(\"----------------------------------------------------------------------------------\");\n        end\n    end\n\n    // Instantiate three karatsuba32 units\n    karatsuba34 k0 (\n        .clk(clk), .rst(rst), .start(start_z0),\n        .A(A_lo), .B(B_lo), .P(z0), .valid_out(v0)\n    );\n\n    karatsuba34 k1 (\n        .clk(clk), .rst(rst), .start(start_z1),\n        .A(A_hi), .B(B_hi), .P(z1), .valid_out(v1)\n    );\n\n    karatsuba34 k2 (\n        .clk(clk), .rst(rst), .start(start_z2),\n        .A(A_lo + A_hi), .B(B_lo + B_hi), .P(z2), .valid_out(v2)\n    );\n\n    // FSM states\n    typedef enum logic [2:0] {\n        IDLE,\n        START_P0, WAIT_P0,\n        START_P1, WAIT_P1,\n        START_P2, WAIT_P2,\n        COMBINE\n    } state_t;\n\n    state_t state;\n\n    logic [127:0] P_reg;\n    assign P = P_reg;\n\n    logic valid_reg;\n    assign valid_out = valid_reg;\n\n    logic [100:0] P_full;\n    logic [200:0] z0_ext, z1_ext, mid_ext;\n\n    // FSM and combination logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state      <= IDLE;\n            P_reg      <= 0;\n            valid_reg  <= 0;\n            start_z0   <= 0;\n            start_z1   <= 0;\n            start_z2   <= 0;\n        end else begin\n            // defaults\n            start_z0  <= 0;\n            start_z1  <= 0;\n            start_z2  <= 0;\n            valid_reg <= 0;\n\n            case (state)\n                IDLE: \n                    if (start) state <= START_P0;\n\n                // Stage 0: compute z0 = A_lo*B_lo\n                START_P0: begin\n                    start_z0 <= 1;\n                    state     <= WAIT_P0;\n                end\n                WAIT_P0: if (v0) state <= START_P1;\n\n                // Stage 1: compute z1 = A_hi*B_hi\n                START_P1: begin\n                    start_z1 <= 1;\n                    state     <= WAIT_P1;\n                end\n                WAIT_P1: if (v1) state <= START_P2;\n\n                // Stage 2: compute z2 = (A_hi+A_lo)*(B_hi+B_lo)\n                START_P2: begin\n                    start_z2 <= 1;\n                    state     <= WAIT_P2;\n                end\n                WAIT_P2: if (v2) state <= COMBINE;\n\n                // Combine results\n                COMBINE: begin\n                    z0_ext  = {{36{1'b0}}, z0};           // 36-bit z0 into 72 bits\n                    z1_ext  = {{36{1'b0}}, z1} << 64;    // 36-bit z1 shifted into upper half\n                    mid_ext = {{36{1'b0}}, (z2 - z1 - z0)} << 32;\n\n                    $display(\"[%0t] --- COMBINE STAGE ---\", $time);\n                    $display(\"   z0   = %d\", z0);\n                    $display(\"   z1   = %d\", z1);\n                    $display(\"   z2   = %d\", z2);\n                    $display(\"   mid  = %d (before shift)\", (z2 - z1 - z0));\n                    $display(\"   z0_ext  = %d\", z0_ext);\n                    $display(\"   z1_ext  = %d\", z1_ext);\n                    $display(\"   mid_ext = %d\", mid_ext);\n\n                    P_full = z1_ext + mid_ext + z0_ext;\n\n                    $display(\"[Kb_64] Product = %h\", P_full);\n                    P_reg     <= P_full;\n                    valid_reg <= 1;\n                    state <=IDLE;\n                end\n            endcase\n        end\n    end\n\nendmodule\n"
    },
    {
      "filename": "tb_B.sv",
      "content": "module tb_B;\n\n    // Signals\n    reg clk;\n    reg rst;\n    reg start;\n    reg [3:0] Data_in1;\n    reg [3:0] Data_in2;\n    wire [7:0] Data_out;\n    reg t_ready;\n    reg [127:0] result;\n\n    integer pass_count = 0;\n    integer fail_count = 0;\n\n    // Instantiate the B module\n    B uut (\n        .clk(clk),\n        .rst(rst),\n        .start(start),\n        .T_Ready(t_ready),\n        .Data_in1(Data_in1),\n        .Data_in2(Data_in2),\n        .Data_out(Data_out)\n    );\n\n    // Dump waves\n    initial begin\n        $dumpfile(\"wave.vcd\");\n        $dumpvars(0, tb_B);\n    end\n\n    // Clock generation: 10ns period\n    initial clk = 0;\n    always #5 clk = ~clk;\n\n    // Task to send 64-bit numbers as nibbles\n    task send_64bit(input [63:0] num1, input [63:0] num2);\n        integer i;\n        begin\n            rst = 1;\n        start = 0;\n       \n        @(posedge clk);  // hold reset at least 1 clock\n        rst = 0;\n        @(posedge clk);  // give FSM a clock to exit reset\n\n            for (i = 15; i >= 0; i = i - 1) begin\n                Data_in1 = num1[i*4 +: 4];\n                Data_in2 = num2[i*4 +: 4];\n                start = (i == 15); // only first nibble pulses 'start'\n                @(posedge clk);\n            end\n            Data_in1 = 0;\n            Data_in2 = 0;\n            start = 0;\n        end\n    endtask\n\n    // Task to receive 128-bit product\n    task receive_product(output reg [127:0] product);\n        integer i;\n        begin\n            product = 0;\n\n            // Wait for first valid byte\n            i = 0;\n            do begin\n                @(posedge clk);\n            end while (!(t_ready && Data_out !== 8'hFF));\n\n            product[0 +: 8] = Data_out;\n\n            // Capture remaining 15 bytes\n            for (i = 1; i < 16; ) begin\n                @(posedge clk);\n                if (t_ready) begin\n                    product[i*8 +: 8] = Data_out;\n                    i = i + 1;\n                end\n            end\n        end\n    endtask\n\n    // Task to receive and check product automatically\n    task receive_and_check(input [127:0] expected_product);\n        reg [127:0] product;\n        begin\n            receive_product(product);\n            $display(\"TB:[%0t] Received product = %032h (expected %032h)\",$time, product, expected_product);\n            if (product === expected_product) begin\n                $display(\"TB: PASS âœ…\");\n                pass_count = pass_count + 1;\n            end else begin\n                $display(\"TB: FAIL âŒ\");\n                fail_count = fail_count + 1;\n            end\n        end\n    endtask\n\n    // Initialize ready signal\n    initial t_ready = 1;\n\n    // Main test sequence\n    initial begin\n        // Reset\n        rst = 1;\n        start = 0;\n        Data_in1 = 0;\n        Data_in2 = 0;\n        t_ready = 1;\n        #20;\n        @(posedge clk);\n        rst = 0;\n\n        // ---- Test 1: 1*8 ----\n        send_64bit(64'h0000000000000001, 64'h0000000000000008);\n        receive_and_check(128'd8);\n\n        // ---- Test 2: 2*3 ----\n        send_64bit(64'h0000000000000002, 64'h0000000000000003);\n        receive_and_check(128'd6);\n\n        // Uncomment for additional edge cases or regression tests\n        \n        send_64bit(64'hFAFAFAFAFAFAFAFA, 64'hFAFAFAFAFAFAFAFA);\n        receive_and_check(128'hFAFAFAFAFAFAFAFA * 128'hFAFAFAFAFAFAFAFA);\n\n        send_64bit(64'hFFFFFFFFFFFFFFFF, 64'hFFFFFFFFFFFFFFFF);\n        receive_and_check(128'hFFFFFFFFFFFFFFFF * 128'hFFFFFFFFFFFFFFFF);\n\n        send_64bit(64'h1000000000000000, 64'h1000000000000000);\n        receive_and_check(128'd0);\n\n        repeat (20) begin\n            bit [63:0] A = $urandom();\n            bit [63:0] B = $urandom();\n            $display(\"TB: Sending random A=%h, B=%h\", A, B);\n            send_64bit(A, B);\n            receive_and_check(128'(A) * 128'(B));\n        end\n        \n\n        // Finish\n        $display(\"TB: All done at time %0t\", $time);\n        $display(\"TB: Total PASS = %0d, Total FAIL = %0d\", pass_count, fail_count);\n        $finish;\n    end\n\nendmodule\n"
    },
    {
      "filename": "B.sv",
      "content": "\n\nmodule B(\n    input clk,\n    input rst,\n    input start,\n    input  T_Ready,\n\n    input [3:0] Data_in1,\n    input [3:0] Data_in2,\n    output reg [7:0] Data_out\n);\n\n    reg [63:0] number1;\n    reg [63:0] number2;\n    reg [5:0] bit_count;\n    reg storing;\n\n    // ---------- Stage 1 ----------\n    reg [3:0] in1_stage1, in2_stage1;\n    reg [5:0] count_stage1;\n    reg valid_stage1;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            in1_stage1   <= 4'b0;\n            in2_stage1   <= 4'b0;\n            count_stage1 <= 6'd0;\n            storing      <= 1'b0;\n            valid_stage1 <= 1'b0;\n        end else begin\n            if (start && fifo_count<4) begin\n                // ðŸš€ First nibble captured immediately\n                storing      <= 1'b1;\n                count_stage1 <= 6'd1;   // first nibble index\n                in1_stage1   <= Data_in1;\n                in2_stage1   <= Data_in2;\n                valid_stage1 <= 1'b1;\n            end else if (storing) begin\n                // ðŸš€ Subsequent nibbles\n                in1_stage1   <= Data_in1;\n                in2_stage1   <= Data_in2;\n                count_stage1 <= count_stage1 + 1;\n                valid_stage1 <= 1'b1;\n\n                if (count_stage1 == 6'd15) begin\n                    storing <= 1'b0;  // all 16 nibbles done\n                end\n            end else begin\n                valid_stage1 <= 1'b0;\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (valid_stage1) begin\n            // $display(\"Stage1: count=%d in1=%h in2=%h\",\n            //           count_stage1, in1_stage1, in2_stage1);\n        end\n    end\n\n    // ---------- Stage 2 ----------\n    reg [63:0] shifted1_stage2, shifted2_stage2;\n    reg [5:0] count_stage2;\n    reg valid_stage2;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            shifted1_stage2 <= 0; \n            shifted2_stage2 <= 0;\n            count_stage2    <= 0; \n            valid_stage2    <= 0;\n        end else if (valid_stage1) begin\n          shifted1_stage2 <= in1_stage1 << ((16 - count_stage1) * 4);\n          shifted2_stage2 <= in2_stage1 << ((16 - count_stage1) * 4);\n            count_stage2    <= count_stage1;\n            valid_stage2    <= 1;\n        end else begin\n            valid_stage2 <= 0;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (valid_stage2) begin\n            // $display(\"Stage2: count=%d shifted1=%h shifted2=%h\",\n            //           count_stage2, shifted1_stage2, shifted2_stage2);\n        end\n    end\n\n    // ---------- Stage 3 ----------\n    reg [63:0] number1_stage3, number2_stage3;\n    reg [5:0] count_stage3;\n    reg valid_stage3;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            number1_stage3 <= 0; \n            number2_stage3 <= 0;\n            count_stage3   <= 0; \n            valid_stage3   <= 0;\n        end else if (valid_stage2) begin\n          if (count_stage2 == 6'd1) begin\n            // first nibble â†’ reset accumulators\n            number1_stage3 <= shifted1_stage2;\n            number2_stage3 <= shifted2_stage2;\n        end else begin\n            number1_stage3 <= number1_stage3 | shifted1_stage2;\n            number2_stage3 <= number2_stage3 | shifted2_stage2;\n        end\n            count_stage3   <= count_stage2;\n            valid_stage3   <= 1;\n        end else begin\n            valid_stage3 <= 0;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (valid_stage3) begin\n            // $display(\"Stage3: count=%d num1=%h num2=%h\",\n            //           count_stage3, number1_stage3, number2_stage3);\n        end\n    end\n\n// FIFO to hold assembled number pairs\nreg [63:0] fifo_num1 [0:3];   // depth 4 FIFO for number1\nreg [63:0] fifo_num2 [0:3];   // depth 4 FIFO for number2\nreg [1:0] fifo_wr_ptr;        // write pointer\nreg [1:0] fifo_rd_ptr;        // read pointer\nreg [2:0] fifo_count;         // number of entries in FIFO\n  \nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        fifo_wr_ptr <= 0;\n        fifo_count <= 0;\n    end else if (valid_stage3 && count_stage3 == 16) begin\n        if (fifo_count < 4) begin   // âœ… Only write if FIFO not full\n            fifo_num1[fifo_wr_ptr] <= number1_stage3;\n            fifo_num2[fifo_wr_ptr] <= number2_stage3;\n            fifo_wr_ptr <= fifo_wr_ptr + 1;\n            fifo_count <= fifo_count + 1;\n            //> $display(\"FIFO WRITE: ptr=%d num1=%h num2=%h count=%d\", fifo_wr_ptr, number1_stage3, number2_stage3, fifo_count+1);\n        end else begin\n            //> $display(\"FIFO FULL! Skipping input. ptr=%d fifo_count=%d\", fifo_wr_ptr, fifo_count);\n        end\n\n    end\nend\n  \n    // Final output combine (optional)\n\n\n\n// always @(posedge clk or posedge rst) begin\n//     if (rst) begin\n//         fifo_rd_ptr <= 0;\n//         Data_out_reg <= 0;\n//     end else if (fifo_count > 0) begin\n//         // Example: multiply numbers and output\n//      	 Data_out_reg <={ fifo_num1[fifo_rd_ptr] , fifo_num2[fifo_rd_ptr]};\n//      	 $display(\"FIFO READ / Data_out: ptr=%d Data_out=%h count=%d\",\n//                   fifo_rd_ptr, Data_out_reg, fifo_count-1);\n//         fifo_rd_ptr <= fifo_rd_ptr + 1;\n//         fifo_count <= fifo_count - 1;\n//     end\n// end\nlogic [127:0] product;\nlogic valid_product;     // connected to kar_inst.valid_out\nlogic [63:0] kar_A, kar_B;\nlogic kar_start;\n         // pulse driven by FSM\nlogic [127:0] cur_product;   // Current 128-bit product being sent\nlogic [3:0] byte_idx;        // Which byte of cur_product we are sending\nlogic sending;               // Are we currently sending a product?\n\n\n// Output product FIFO must buffer up to 96 cycles of stall\nlocalparam PROD_FIFO_DEPTH = 8;   // â‰¥6 required, use 8 for simplicity\n\nlogic [127:0] product_fifo[PROD_FIFO_DEPTH-1:0];\nlogic [$clog2(PROD_FIFO_DEPTH)-1:0] prod_wr_ptr, prod_rd_ptr;\nlogic [$clog2(PROD_FIFO_DEPTH):0]   prod_count;  // needs +1 bit for full/empty\n\n\n// connect kar_inst to kar_start and captured operands\nkaratsuba64 kar_inst (\n    .clk(clk),\n    .rst(rst),\n    .start(kar_start),\n    .A(kar_A),\n    .B(kar_B),\n    .P(product),\n    .valid_out(valid_product)\n);\n\n// FSM type\ntypedef enum logic [1:0] {IDLE, START_MUL, WAIT_DONE, OUTPUT} mul_state_t;\nmul_state_t mul_state;\n\n// initialize in reset\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        mul_state   <= IDLE;\n        fifo_rd_ptr <= '0;\n        fifo_count  <= '0;\n        kar_start   <= 1'b0;\n        kar_A       <= 64'd0;\n        kar_B       <= 64'd0;\n         prod_wr_ptr <= 0;\n    prod_rd_ptr <= 0;\n    prod_count  <= 0;\n    end else begin\n        // default: no start pulse unless we assert explicitly in START_MUL\n        kar_start <= 1'b0;\n\n        case (mul_state)\n            IDLE: begin\n                // only detect available data here and move to START_MUL;\n                // do not read FIFO in the same cycle; read when in START_MUL.\n                if (fifo_count > 0) begin\n                //>     $display(\"[FSM] %0t IDLE -> START_MUL (rd_ptr=%0d count=%0d)\", $time, fifo_rd_ptr, fifo_count);\n                    mul_state <= START_MUL;\n                end\n            end\n\n            START_MUL: begin\n                // capture FIFO head into local regs (freeze inputs)\n                kar_A <= fifo_num1[fifo_rd_ptr];\n                kar_B <= fifo_num2[fifo_rd_ptr];\n\n                // pulse start for one cycle\n                kar_start <= 1'b1;\n\n                //> $display(\"[FSM] %0t START_MUL: captured A=%h B=%h ptr=%0d\", $time, fifo_num1[fifo_rd_ptr], fifo_num2[fifo_rd_ptr], fifo_rd_ptr);\n\n                // move to wait state\n                mul_state <= WAIT_DONE;\n            end\n\n            WAIT_DONE: begin\n                // we already pulsed kar_start for 1 cycle in previous state; here we wait\n                   //> $display(\"[FSM] %0t WAIT_DONE: waiting for valid_product=%b\", $time, valid_product);              \n                      if (valid_product) begin\n                    // latch product into output register\n                    product_fifo[prod_wr_ptr] <= product;\n                    prod_wr_ptr <= prod_wr_ptr + 1;\n                    prod_count <= prod_count + 1;\n\n                    // advance FIFO read pointer and decrement count (non-blocking)\n                    fifo_rd_ptr <= fifo_rd_ptr + 1;\n                    fifo_count  <= fifo_count - 1;\n\n                   //> $display(\"[FSM] %0t PRODUCT READY: product=%h (old_rd=%0d) fifo_count(before)=%0d\",$time, product, fifo_rd_ptr, fifo_count);\n\n                    // go back to IDLE to process next FIFO entry\n                    mul_state <= IDLE;\n                end\n            end\n\n            default: mul_state <= IDLE;\n        endcase\n    end\nend\n\nalways_ff @(posedge clk or posedge rst) begin\n    if (rst) begin\n        sending <= 0;\n        prod_rd_ptr <= 0;\n        byte_idx <= 0;\n        Data_out <= 0;\n    end else begin\n        if (!sending) begin\n            // Start sending next product if FIFO not empty\n            if (prod_count > 0) begin\n                cur_product <= product_fifo[prod_rd_ptr];\n                prod_rd_ptr <= prod_rd_ptr + 1;\n                prod_count <= prod_count - 1;\n                sending <= 1;\n                byte_idx <= 0;\n            end\n            else if (T_Ready) begin\n                Data_out <= 8'hFF; // No data â†’ send idle token\n            end\n        end else if (T_Ready) begin\n            // Send next byte of current product\n            Data_out <= cur_product[byte_idx*8 +: 8];\n            if (byte_idx == 15) sending <= 0;  // all bytes sent\n            else byte_idx <= byte_idx + 1;\n        end\n    end\nend\n\nendmodule\n"
    },
    {
      "filename": "mult18.sv",
      "content": "module mult18(\n    input  logic        clk,\n    input  logic        rst,\n    input  logic        start,\n    input  logic [17:0] A,\n    input  logic [17:0] B,\n    output logic        done,\n    output logic [35:0] P\n);\n\n    logic busy;\n    always_ff @(posedge clk) begin\n        if (0) begin\n            $display(\"----------------------------------------------------------------------------------\");\n            $display(\"[%0t]mult18 Input A=%d (%0d bits), B=%d (%0d bits)\", \n                    $time, A, $bits(A), B, $bits(B));\n            \n            $display(\"----------------------------------------------------------------------------------\");\n\n        end\n    end\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            P    <= 36'b0;\n            done <= 0;\n            busy <= 0;\n        end else begin\n            if (start && !busy) begin\n                // Perform multiplication\n                P    <= A * B;   // 18Ã—18 â†’ 36 bits\n                done <= 1;       // keep 'done' high until start goes low\n                busy <= 1;\n            end else if (!start) begin\n                done <= 0;\n                busy <= 0;\n            end\n        end\n    end\nendmodule\n"
    }
  ]
}
